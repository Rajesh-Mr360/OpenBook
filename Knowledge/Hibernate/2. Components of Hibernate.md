Let’s look at the main components and concepts that make Hibernate work.
1. **Configuration**
2. **SessionFactory**
3. **Session**
4. **Transaction**
5. **Query**
6. **Criteria**

# 1. Configuration

The Hibernate configuration is essential for setting up the framework and establishing the connection between the Java application and the database, so that it knows **how to connect to the database** and **how to map Java classes to database tables**.

In simple words, it tells Hibernate: **Which database to use ? __ How to connect to it ? __ Which Java classes are entities ? __ What Hibernate settings should be applied ?**

There are two common ways to configure Hibernate:
1. XML Based Configuration
2. Java Configuration

## 1.1. XML Based Configuration
In the XML-based approach, all database connection details, Hibernate properties, and entity mappings are defined in a file called `hibernate.cfg.xml`. When the application starts, Hibernate reads this XML file using the `Configuration` class, loads the settings, registers the mapped entity classes, and creates a `SessionFactory`. From this `SessionFactory`, Hibernate opens `Session` objects that are used to perform database operations.

## 1.2. Java Based Configuration
In the Java-based configuration approach, the same information is provided directly through Java code using properties and annotations. Entity classes are annotated with annotations such as `@Entity` and `@Table` to define table mappings, while database and Hibernate settings are set programmatically using the `Configuration` class. 

Although the way configuration is defined is different, internally Hibernate follows the same flow in both approaches—reading the configuration, building the `SessionFactory`, creating sessions, and interacting with the database. In simple terms, XML configuration stores settings in an external file, while Java configuration defines them in code, but both achieve the same goal of enabling Hibernate to manage database interactions using Java objects.
# 2. SessionFactory
The SessionFactory is an interface in hibernate that is responsible for creating and managing session instances. It is created during the application’s start up based on the configuration settings by the configuration object. SessionFactory is a heavy weight object and typically only one instance will be created in a application but if your application needs to interact with multiple databases, each with its own configuration, you may consider having a separate SessionFactory for each database. This allows you to manage the connections, configurations, and transactions independently for each database.

Creating a SessionFactory is a resource-intensive operation. It involves parsing configuration files, setting up connection pools, and other initialization steps. Frequent creation of new SessionFactory instances can lead to unnecessary resource consumption, such as increased memory usage and CPU cycles.

SessionFactory holds second-level cache (optional) of data.
# 3. Session
Session object holds first level of cache (mandatory).

In Hibernate, Session is an interface between the data stored in the database and the application. It acts as a bridge between your Java application and Hibernate's ORM (Object-Relational Mapping) capabilities.
- The primary purpose of a Session is to perform CRUD (Create, Read, Update, Delete) operations on persistent objects. It allows you to save, delete, and update instances of persistent classes. 
- Session objects are used to manage transactions. They provide methods to begin, commit, and roll back transactions, making it easier to ensure data consistency.
- Sessions include a first-level cache (session cache) for storing objects that have been loaded or created during the session's lifecycle. This cache helps improve performance by reducing the number of database calls.
- It allows you to create and execute HQL (Hibernate Query Language) or Criteria queries, facilitating complex data retrieval operations.

# 4. Transaction

Let’s understand transactions with the an example, if a user has entered his information the user’s information gets stored in the `user_info` table. Now, to book a ticket he makes an online payment and due to some reason(system failure) the payment has been cancelled so, the ticket is not booked for him. But, the problem is that his information gets stored on the `user_info` table. On a large scale, more than thousands of these things happen within a single day. So, it is not good practice to store a single action of the transaction(Here, only user info is stored not the payment info).

To overcome these problems, spring provides transaction management, which uses annotation to handle these issues. In such a scenario, spring stores the user information in temporary memory and then checks for payment information if the payment is successful then it will complete the transaction otherwise it will roll back the transaction and the user information will not get stored in the database.

A **transaction** simply represents a unit of work. In such case, if one step fails, the whole transaction fails (which is termed as atomicity). In Hibernate, transactions ensure the ACID properties (Atomicity, Consistency, Isolation, Durability) for database operations:

- **Atomicity:** All database changes within a transaction are treated as a single unit. Either all succeed or all fail.
- **Consistency:** The database transitions from one valid state to another after a transaction.
- **Isolation:** Transactions are isolated from each other, preventing conflicts between concurrent operations.
- **Durability:** Once a transaction is committed, the changes are persisted permanently in the database.

Hibernate provides a `Transaction` interface for managing transactions. However, you typically won't use it directly. Instead, you'll leverage either:

- **Programmatic Transaction Management:** You manually begin, commit, and rollback transactions using the `Session` object's `beginTransaction()`, `commit()`, and `rollback()` methods.
- **Declarative Transaction Management (Spring only):** Spring's `@Transactional` annotation offers a concise way to declare transactional behaviour on methods or classes.

# 5. Query & Criteria

Hibernate provides **Criteria** and **Query** components to **retrieve data from the database** in an easy and flexible way without writing complex SQL all the time. These components help developers fetch, filter, and sort data using **object-oriented concepts**.

## Query Component

The **Query** component is mainly used to execute **HQL (Hibernate Query Language)** or **JPQL** queries. HQL looks similar to SQL but works with **entity class names and fields**, not table names and columns. This makes queries independent of the database and easier to maintain. Using the Query component, developers can perform operations like selecting records, applying conditions, joining entities, and using pagination. The `Query` object is created using a `Session` or `EntityManager`, parameters are set dynamically, and then the query is executed to fetch results as Java objects.

In simple words, the Query component allows you to **write database queries in an object-oriented way instead of raw SQL**.

## Criteria Component

The **Criteria** component provides a **programmatic and dynamic way** to build queries using Java code rather than writing query strings. With Criteria, conditions are added using methods, making it useful when query conditions are not fixed and depend on user input or runtime logic. Hibernate Criteria builds queries step by step using restrictions, sorting, and projections, and then converts them into SQL internally. This approach improves readability and reduces errors caused by incorrect query strings.

In simple words, Criteria allows you to **build queries using Java code**, which is especially helpful for dynamic search conditions.

## In Short
Hibernate Query is **string-based and closer to SQL**, while Hibernate Criteria is **code-based and more flexible**. Both help Hibernate fetch data efficiently while keeping database interaction object-oriented and database-independent.
