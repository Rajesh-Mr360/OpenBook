## Why Do We Need Transaction Management?

In simpler terms, the transaction management feature helps you ensure that when you're making changes to your database, either all those changes are saved successfully, or none of them are. This prevents situations where only some changes are saved, leaving your data in an inconsistent state.

Imagine you're transferring money between two bank accounts. With transaction management, if something goes wrong during the transfer, like an error or a system crash, the entire transaction is rolled back, so neither account ends up with the wrong balance.

To overcome these problems, spring provides transaction management, which uses annotation to handle these issues. In such a scenario, spring stores the user information in temporary memory and then checks for payment information if the payment is successful then it will complete the transaction otherwise it will roll back the transaction and the user information will not get stored in the database.

A **transaction** simply represents a unit of work. In such case, if one step fails, the whole transaction fails (which is termed as atomicity). In Hibernate, transactions ensure the ACID properties (Atomicity, Consistency, Isolation, Durability) for database operations:

- **Atomicity:** All database changes within a transaction are treated as a single unit. Either all succeed or all fail.
- **Consistency:** The database transitions from one valid state to another after a transaction.
- **Isolation:** Transactions are isolated from each other, preventing conflicts between concurrent operations.
- **Durability:** Once a transaction is committed, the changes are persisted permanently in the database.

Hibernate provides a `Transaction` interface for managing transactions. However, you typically won't use it directly. Instead, you'll leverage either:

- **Programmatic Transaction Management:** You manually begin, commit, and rollback transactions using the `Session` object's `beginTransaction()`, `commit()`, and `rollback()` methods.
- **Declarative Transaction Management (Spring only):** Spring's `@Transactional` annotation offers a concise way to declare transactional behaviour on methods or classes.
---
**Implementation in Maven Project**

Here's a basic example of programmatic transaction management in a non-Spring Maven project:

```
import org.hibernate.Session; 
import org.hibernate.SessionFactory; 
import org.hibernate.Transaction; 

public class MyService { 
	private SessionFactory sessionFactory; 
	
	public void saveData(Object entity) { 
		Session session = sessionFactory.openSession(); 
		Transaction transaction = null; 
		try { 
			transaction = session.beginTransaction(); 
			session.save(entity); 
			transaction.commit(); 
		} catch (Exception e) { 
			if (transaction != null) { 
				transaction.rollback(); 
			} 
			throw e; // Or handle the exception appropriately 
		} finally { 
			if (session != null) { 
			session.close(); 
			} 
		} 
	} 
}
```
---

**Implementation in Spring Boot Project**

Spring Boot simplifies transaction management using the `@Transactional` annotation:

```
@Service 
public class MyService { 
	@Autowired private SessionFactory sessionFactory; 
	
	@Transactional 
	public void saveData(Object entity) {
		// No need for explicittransaction management here
		sessionFactory.getCurrentSession().save(entity);
	}
}
```

**Key Points**

- Spring Boot automatically configures a `PlatformTransactionManager` based on your project setup, handling transaction lifecycle.
- Configure connection pooling and transaction isolation levels in your data source configuration (e.g., `application.properties`).
- Consider using Spring's `@Transactional` for cleaner code in most cases.

> To use `@Transactional` annotation, you need to configure transaction management by using `@EnableTransactionManagement` to your main class of Spring Boot application.

