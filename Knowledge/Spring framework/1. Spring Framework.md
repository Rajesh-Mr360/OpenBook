In earlier days of Java development, enterprise applications were commonly built using EJB and Struts technologies. This often made development slow, complex, and tightly coupled, as developers had to write a lot of boilerplate code even for simple features. The **Spring Framework** was introduced to address these challenges. It follows the principles of **Inversion of Control (IoC)** and **Dependency Injection (DI)** to remove tight coupling between components, making the code easier to maintain and test.

# Introduction to Spring Framework

Spring is a lightweight, loosely coupled, and integrated framework designed to reduce the complexity of developing enterprise-level applications. It is often called a **"Framework of Frameworks"** because it provides support and seamless integration with many popular technologies such as **Hibernate**, **Struts**, **EJB**, and more.

The Spring framework is built on two core principles: **Inversion of Control (IoC)** and **Dependency Injection (DI)**. These concepts help Spring manage the lifecycle of its beans and automatically inject the required dependencies during runtime, allowing developers to build loosely coupled applications.

Spring follows a **Modular Architecture** that consists of multiple independent modules. Developers can choose only the required modules based on their application needs while ignoring the rest. This keeps the application lightweight and focused.  

_For example: If we only want to build REST APIs using Spring Web, we don’t need to include database-related modules like Spring Data JPA._

# Features of Spring framework
1. Inversion of Control - IOC
2. Dependency Injection
3. Transaction Management
4. Aspect Oriented Programming

## 1. Inversion of Control - IOC

**Inversion of Control (IoC)** is a design principle in which a software component is designed to receive its dependencies from an external source, rather than creating them itself. In Spring, this is achieved using IOC container with help of **Dependency injection (DI)**.

The container is responsible for creating the objects, wire them together, configure them, and manage their complete life cycle from creation till destruction. The Spring container uses DI to manage the components that make up an application. These objects are called Spring Beans.

## 2. Dependency Injection

Dependency injection is a fundamental concept of spring framework, through which the **spring container** injects one object into other objects. Simply put, this allows spring framework to develop a loosely coupled application and move the responsibility of managing the beans onto the container.

In Dependency Injection, you do not have to create your objects but have to describe how they should be created. You don’t connect your components and services together in the code directly, but describe which services are needed by which components in the configuration file. The IoC container will wire them up together.

**Dependency injection can be achieved in two ways:**
1. **Constructor dependency injection :** In this method, dependencies are passed as a parameter to the class’s constructor. This ensures that all the dependencies are injected upon the instantiation of an object. We utilise the `@Autowired` Annotation on top of the constructors to achieve this.
2. **Setter dependency injection :** This is another way to inject dependencies and its done by using a setter or getter methods to do so. We can do so by annotating a setter method with `@Autowired` and it’ll do the work. A key point here is that, dependencies will only be injecting when the setter/getter methods are called.

## 3. Transaction Management

In simpler terms, the transaction management feature in the Spring framework helps you ensure that when you're making changes to your database, either all those changes are saved successfully, or none of them are. This prevents situations where only some changes are saved, leaving your data in an inconsistent state.

Imagine you're transferring money between two bank accounts. With transaction management, if something goes wrong during the transfer, like an error or a system crash, the entire transaction is rolled back, so neither account ends up with the wrong balance.

In the Spring framework, transaction management is achieved primarily through two approaches:

1. **Programmatic Transaction Management**: This involves explicitly coding transaction demarcation using Spring's `TransactionTemplate` or directly through the `PlatformTransactionManager` interface. Developers manually control transaction boundaries in their code by starting, committing, or rolling back transactions.

2. **Declarative Transaction Management**: This approach involves configuring transactions declaratively, usually via annotations like `@Transactional`. Developers annotate methods or classes to specify transactional behavior. Spring AOP (Aspect-Oriented Programming) intercepts method calls and automatically starts, commits, or rolls back transactions based on the configuration.

Both approaches offer flexibility and ease of use, with declarative transaction management being more commonly used due to its simplicity and reduced boilerplate code.

## 4. Aspect Oriented Programming

**Aspect-Oriented Programming (AOP)** is a programming approach used to **separate common, repeated tasks from business logic** so that the code becomes cleaner and easier to maintain. In real applications, there are some functionalities like **logging, security, transaction management, and exception handling** that are needed in many places across the application. If we write this code inside every method, the code becomes messy and repetitive. AOP solves this by allowing these common concerns to be written **once in a separate module called an aspect**, and then automatically applied to the required methods. This way, the core business logic stays clean, and cross-cutting concerns are handled transparently without mixing them into the main code.