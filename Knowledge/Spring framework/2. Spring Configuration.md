# Spring Configuration

Spring Core Configuration is the process of configuring the Spring Framework, which involves specifying the various configuration details required for an application to function properly. This can include setting up beans, specifying bean dependencies, configuring aspect-oriented programming (AOP) aspects, and more.

There are several ways to configure a Spring application, including: 
1. **XML-based configuration**
2. **Java-based configuration**
3. **Annotation-based configuration**


## 1. XML-based Configuration

In the early days of Spring, XML configuration was the primary method used to configure Spring applications. Configuration details such as bean definitions, dependencies, and aspects were specified in XML files, typically named `applicationContext.xml` or similar.

```
<beans>  
<bean id="userService" class="com.example.UserService">  
<property name="userRepository" ref="userRepository"/>  
</bean>  
  
<bean id="userRepository" class="com.example.UserRepository"/>  
</beans>
```

In this example, `userService` and `userRepository` are beans defined with their respective classes. The `userService` bean has a dependency on the `userRepository` bean, which is injected using setter injection.

**Beans** are just essentially POJOs in apps, using **beans** here replaces calling the new keyword. Using the xml file in our Application class should be done like this.

```
ApplicationContext appContext = new ClassPathXmlApplicationContext("applicationContext.xml");  
  
UserService service = appContext.getBean("userService", UserService.class);
```

## 2. Annotation-based Configuration

Annotations can be used to replace xml based configuration to create spring IOC Container. Adding annotation such as `@Component`, `@Configuration` …etc to the source level of class is an example of how spring bean is declared. When the spring IOC Container scans the classpath, It will load and register all the annotated beans so that they become managed spring beans.

The following are some of the annotation used to define class as managed bean in spring. `@Component`, `@Configuration`, `@Controller`, `@Service`, `@Repository`, `@Entity` ..etc.

Any class marked with above annotation will be loaded and registered by spring while scanning classpath.

``` ln:false
<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="[http://www.springframework.org/schema/beans](http://www.springframework.org/schema/beans)"  
       xmlns:xsi="[http://www.w3.org/2001/XMLSchema-instance](http://www.w3.org/2001/XMLSchema-instance)"  
       xsi:schemaLocation="[http://www.springframework.org/schema/beans](http://www.springframework.org/schema/beans)     
 [http://www.springframework.org/schema/beans/spring-beans.xsd](http://www.springframework.org/schema/beans/spring-beans.xsd)">  
    xmlns:context="[http://www.springframework.org/schema/context](http://www.springframework.org/schema/context)"  
    xsi:schemaLocation="...  
    [http://www.springframework.org/schema/context](http://www.springframework.org/schema/context)  
    [http://www.springframework.org/schema/context/spring-](http://www.springframework.org/schema/context/spring-)  
    context.xsd">  
  
    <context:annotation-config/>  
    <context:component-scan base-package="com.example"/>  
  
</beans>
```

Here we can see we add the context namespace, annotation config and component scanner to look in the `com.example` package. We use **stereotype annotations** to mark the classes we want and **@Autowired** to set it up.

``` ln:false
@Configuration  
public class AppConfig {  
	@Bean  
	public UserService userService() {  
		return new UserService(userRepository());  
	}  
	  
	@Bean  
	public UserRepository userRepository() {  
		return new UserRepository();  
	}  
}
```

## 3. Java Configuration

This is the last and by far the best way to configure spring applications. It is preferred because you do not have to use any xml for your configurations and everything is done in the Java file.

 **`@Bean-@Configuration`**

In the following section, we will look at how to configure, initialize and assemble beans using java based container configuration. The two main annotation that we would use are `@Bean` and `@Configuration`. `@Bean` annotation plays the same role as `<bean/>` element from XML. `@Bean` annotation specified on method indicates that the annotated method would create, configure and initialize new instance of bean. `@Bean` annotated method would be specified in `@Configuration` class.

Any class that is annotated with `@Configuration` denotes that the class will be a source for bean definitions. The following example shows how `@Configuration` and `@Bean` annotation acts as metadata for the spring to load and register `AppConfig`, `FileServiceConfig` beans into the container.

``` ln:false
// configuration with bean definitions  
  
@Configuration  
class AppConfig {  
	@Bean  
	public FileServiceConfig fileServiceConfig() {  
		FileServiceConfig fileServiceConfig = new FileServiceConfig();  
		fileServiceConfig.setStoragePath("/tmp");  
		fileServiceConfig.setMaxFileSize(12390000);  
		return fileServiceConfig;  
	}    
}  

public class Main {
	public static void main(String[] args) {   
		AnnotationConfigApplicationContext ctx =  
		new AnnotationConfigApplicationContext(AppConfig.class);  
		FileServiceConfig fileServiceConfig = ctx.getBean("fileServiceConfig");  
		System.out.println(fileServiceConfig);  
	}
}
```

applicationContext.xml is replaced by `@Configuration` as a class level annotation. We can choose to use constructor, setter or property injection. We can also optionally remove bean declarations here and use stereotypes to declare them like in the previous section.