## Role of API Gateway and the Need for Service Discovery
API Gateways are commonly used to route traffic between clients and internal microservices. They handle responsibilities such as routing, authentication, rate limiting, and aggregation.

However, an important question arises:
- How does the API Gateway know **which backend microservice** to call?
- How does it know the **target IP address and port** of a service that can dynamically scale up or down?

Hardcoding IPs and ports is not feasible in a dynamic microservices environment. This problem is solved by applying the **Service Registry pattern**, which enables **Service Discovery**.


## What is Service Discovery?
==In a microservices architecture, each service is responsible for a specific business functionality. Since services must interact with each other to function as a complete system, they need a way to **dynamically discover** each other.== **Service Discovery** addresses this problem by maintaining a list of currently running service instances along with their network locations. It allows services to locate and communicate with each other without relying on hardcoded configurations, providing **flexibility**, **scalability**, and **fault tolerance** in distributed systems.

## How Service Discovery Works

So far, we’ve assumed that the Service Registry already knows the locations of each microservice. But how do registration and deregistration actually happen? There are **two common registration strategies**:
1. **Self-Registration**
2. **Third-Party Registration**
### Self-Registration

In **self-registration**, a service instance is responsible for registering and deregistering itself with the **Service Registry**. When the service starts up, it automatically sends a **registration request** to the registry with details such as its service name (alias), IP address, port number, metadata, and health-check endpoint. 

Once registered, the service periodically sends **heartbeat signals** to the registry at fixed intervals to indicate that it is still running and healthy. The Service Registry monitors service health primarily by tracking these heartbeats—if a service fails to send heartbeats within a configured timeout, the registry marks the instance as **unhealthy** and removes it from the list of available services. In some implementations, the registry may also actively invoke the service’s health-check endpoint (such as `/health` in Spring Boot) to verify its status. 

When a service shuts down gracefully, it explicitly sends a **deregistration request** to the registry, ensuring it is immediately removed. This mechanism ensures that only live and healthy service instances are discoverable, enabling dynamic scaling, fault tolerance, and reliable request routing in a microservices architecture.

### Third-Party Registration

In **third-party registration**, the responsibility of registering and deregistering service instances is **not handled by the services themselves** but is instead delegated to an external, centralized component known as a **service registrar** (or infrastructure agent). When a new service instance starts, the registrar—often running as part of the platform or orchestration layer—detects the instance automatically (for example, through container orchestration events in Kubernetes or cloud platforms). The registrar then registers the service instance with the **Service Registry**, including details such as the service name, IP address, port, and metadata. Health monitoring is also handled externally: the registrar continuously checks the service’s health using probes such as HTTP health endpoints, TCP checks, or platform-level signals. If the service becomes unhealthy, crashes, or is terminated, the registrar immediately deregisters it from the registry. This approach decouples services from registry logic, keeps application code clean, and centralizes discovery and health management, but it relies heavily on the underlying infrastructure and introduces an additional component that must be properly configured and maintained.


---
## Types of Service Discovery

There are two main implementations of service discovery:
1. **Client-Side Discovery:** The client asks for the service registry and chooses an available service instance directly. Example: **Netflix Eureka + Ribbon**.
2. **Server-Side Discovery:** A load balancer (e.g., **AWS** **ALB**, **Kubernetes Service**) acts between the client and services, directing requests to the correct instance.

### Client-side Discovery

When using **Client-Side Service Discovery**, the **Consumer Service (client)** is responsible for finding available instances of a target service and doing load balancing. So the client queries the **Service Registry** **to fetch the list of active/available instances** of the service it wants to call. Then the client uses the one of load balancing algorithm to select one of available instances and routes request to that instance.

Giving the responsibility of load balancing to the client in Client-Side Service Discovery has both benefits and drawbacks. The main advantage is that it removes the need for an extra hop through a dedicated load balancer, which reduces latency and improves performance since the client communicates directly with the target service instance. However, this also introduces additional complexity because the Service Consumer must implement and handle the load balancing logic itself. 

Another downside is the tight coupling between the client and the Service Registry. Each client needs to understand how to communicate with the registry, meaning the discovery logic must be implemented separately for every programming language and framework used in the system, which increases development and maintenance effort.

Now that we’ve clarified Client-Side Discovery, let’s take a look at Server-Side Discovery.

### Server-Side Service Discovery

The alternative approach to Service Discovery is the Server-Side Discovery model, where an intermediary component acts as the Load Balancer. Instead of the client locating service instances itself, it simply sends all requests to the load balancer. The load balancer then queries the Service Registry to determine which service instances are currently available and selects one based on its load-balancing strategy. It routes the client’s request to that chosen instance and returns the response back to the client. In this model, the complexity of service discovery and load balancing is offloaded from the client and centralized within the load balancer.

In this approach, a dedicated component — the Load Balancer — is responsible for performing load balancing. This is a major advantage because it abstracts away the complexity from the Service Consumer. The client no longer needs to know where service instances are running or implement discovery logic on its own. As a result, there is no need to create separate discovery integrations for every language or framework used by different clients, making them simpler and more lightweight.

However, the trade-off is that the Load Balancer itself becomes an additional infrastructure component that must be deployed, configured, and maintained. If the deployment platform does not already provide a built-in load balancer, this increases operational overhead.

# Conclusion
Service registry is nothing but another microservice where all the independent services of the application will have to be registered. This registration process includes providing metadata such as the service name, network location (IP address and port), health status, and possibly other attributes.

During the start-up, all other services will get registered in the service registry using an **alias**. Each service could be identified using the respective alias registered. Suppose a microservice named **Microservice-A** is registered in the registry with an alias as **Microservice-A**. Now this service could be identified using the specified alias. i.e. `http://microserviceA` instead of `http://[HOST]:[PORT]/`. Which means the client making the request need not know the IP address and port number of the service instance. For this to work there should be someone in there who translates the alias into specific actual URLs. The mapping in the registry would do this job.
